import {
  and,
  avg,
  count,
  desc,
  eq,
  gte,
  inArray,
  isNotNull,
  lte,
  sql,
} from 'drizzle-orm';
import {
  events,
  journeys,
  locations,
  monkeys,
  routes,
} from '../../db/schema.js';

import db from '../../db/db.js';

export const statsService = {
  getOverviewMetrics: async () => {
    const qrCodesPrinted = await statsService.getQrCodesPrintedCount();
    const qrCodesScanned = await statsService.getQrCodesScannedCount();
    const bananasReturned = await statsService.getBananasReturnedCount();
    const monkeyInteractions = await statsService.getMonkeyInteractionsCount();
    const abandonedInteractionsStats =
      await statsService.getAbandonedInteractionsStats();
    const activeMonkeysStats = await statsService.getActiveMonkeysStats();

    return {
      qrCodesPrinted,
      qrCodesScanned,
      bananasReturned,
      monkeyInteractions,
      activeMonkeys: activeMonkeysStats.activeMonkeys,
      totalMonkeys: activeMonkeysStats.totalMonkeys,
      abandonedInteractionsStats,
    };
  },

  getJourneyCompletionFunnel: async () => {
    const totalInteractions = await statsService.getMonkeyInteractionsCount();
    const printed = await statsService.getQrCodesPrintedCount();
    const scanned = await statsService.getQrCodesScannedCount();
    const verified = await statsService.getBananasReturnedCount();

    const returnedJourneys = verified;
    const scannedOnly = scanned - verified;
    const printedOnly = printed - scanned;
    const interactionsWithoutPrint = totalInteractions - printed;

    const returnedPercentage =
      totalInteractions > 0
        ? Number(((returnedJourneys / totalInteractions) * 100).toFixed(1))
        : 0;

    const scannedOnlyPercentage =
      totalInteractions > 0
        ? Number(((scannedOnly / totalInteractions) * 100).toFixed(1))
        : 0;

    const printedOnlyPercentage =
      totalInteractions > 0
        ? Number(((printedOnly / totalInteractions) * 100).toFixed(1))
        : 0;

    const interactionsWithoutPrintPercentage =
      totalInteractions > 0
        ? Number(
            ((interactionsWithoutPrint / totalInteractions) * 100).toFixed(1)
          )
        : 0;

    const scanRate =
      printed > 0 ? Number(((scanned / printed) * 100).toFixed(1)) : 0;

    console.log(
      `--------> ver: ${verified}, scan: ${scanned}, v/s = ${verified / scanned}, % = ${(verified / scanned) * 100}`
    );

    const verificationRate =
      scanned > 0 ? Number(((verified / scanned) * 100).toFixed(1)) : 0;

    return {
      segments: {
        returnedJourneys,
        scannedOnly,
        printedOnly,
        interactionsWithoutPrint,
      },
      percentages: {
        returnedPercentage,
        scannedOnlyPercentage,
        printedOnlyPercentage,
        interactionsWithoutPrintPercentage,
      },
      stats: {
        totalInteractions,
        totalPrinted: printed,
        scanRate,
        verificationRate,
      },
    };
  },

  getPopularRoutesByQRGenerated: async () => {
    const result = await db
      .select({
        routeId: journeys.routeId,
        qrGenerated: count(journeys.qrToken),
      })
      .from(journeys)
      .where(isNotNull(journeys.qrGeneratedAt))
      .groupBy(journeys.routeId)
      .orderBy(desc(count(journeys.qrToken)))
      .execute();

    console.log('QR Code generated: ', result);

    const routeIds = result.map((r) => r.routeId).filter((r) => r != null);

    const routesInfo = await db
      .select()
      .from(routes)
      .where(inArray(routes.id, routeIds))
      .execute();

    console.log('Routes selected: ', routesInfo);

    const locationIds = [
      ...routesInfo.map((route) => route.sourceLocationId),
      ...routesInfo.map((route) => route.destinationLocationId),
    ];

    const locationsInfo = await db
      .select({
        locationId: locations.id,
        locationName: locations.name,
      })
      .from(locations)
      .where(inArray(locations.id, locationIds))
      .execute();

    console.log('Locations Info: ', locationsInfo);

    const mostPopularRoutesByQRData = result.map((route) => {
      const routeInfo = routesInfo.find((r) => r.id === route.routeId);

      if (!routeInfo)
        throw Error(
          'error while getting popular routes generated by QR. Route Info not found.'
        );
      const sourceLocation = locationsInfo.find(
        (loc) => loc.locationId === routeInfo.sourceLocationId
      );
      const destinationLocation = locationsInfo.find(
        (loc) => loc.locationId === routeInfo.destinationLocationId
      );

      return {
        routeId: route.routeId,
        sourceLocationName: sourceLocation ? sourceLocation.locationName : '',
        destinationLocationName: destinationLocation
          ? destinationLocation.locationName
          : '',
        qrGenerated: route.qrGenerated,
      };
    });
    console.log('most popular routes by qr: ', mostPopularRoutesByQRData);

    return mostPopularRoutesByQRData;
  },

  getRouteEfficiencyMetrics: async () => {
    const qrResult = await db
      .select({
        routeId: journeys.routeId,
        qrGeneratedCount: count(journeys.qrToken),
      })
      .from(journeys)
      .where(isNotNull(journeys.qrToken))
      .groupBy(journeys.routeId)
      .execute();

    const scannedResult = await db
      .select({
        routeId: journeys.routeId,
        qrScannedCount: count(journeys.qrScannedAt),
      })
      .from(journeys)
      .where(isNotNull(journeys.qrScannedAt))
      .groupBy(journeys.routeId)
      .execute();

    const scanTimeResult = await db
      .select({
        routeId: journeys.routeId,
        avgScanTime: avg(
          sql`${journeys.qrScannedAt} - ${journeys.qrGeneratedAt}`
        ),
      })
      .from(journeys)
      .where(
        and(isNotNull(journeys.qrScannedAt), isNotNull(journeys.qrGeneratedAt))
      )
      .groupBy(journeys.routeId)
      .execute();

    const journeyTimeResult = await db
      .select({
        routeId: journeys.routeId,
        avgCompletionTime: avg(
          sql`${journeys.endTime} - ${journeys.startTime}`
        ),
      })
      .from(journeys)
      .where(eq(journeys.status, 'completed'))
      .groupBy(journeys.routeId)
      .execute();

    console.log('Journeys time result: ', journeyTimeResult);

    const routeIds = qrResult.map((r) => r.routeId).filter((r) => r != null);

    const routesInfo = await db
      .select()
      .from(routes)
      .where(inArray(routes.id, routeIds))
      .execute();

    return qrResult.map((routeData) => {
      const routeId = routeData.routeId;
      const routeInfo = routesInfo.find((r) => r.id === routeId);

      const scanned = scannedResult.find((r) => r.routeId === routeId);
      const scanTime = scanTimeResult.find((r) => r.routeId === routeId);
      const completionTime = journeyTimeResult.find(
        (r) => r.routeId === routeId
      );
      const qrGenerated = routeData.qrGeneratedCount;
      const qrScanned = scanned ? scanned.qrScannedCount : 0;

      const scanRate =
        qrGenerated > 0
          ? Number(((qrScanned / qrGenerated) * 100).toFixed(1))
          : 0;

      function formatTime(seconds: number) {
        const date = new Date(seconds * 1000);
        const minutes = date.getUTCMinutes();
        const secondsRemaining = date.getUTCSeconds();
        return `${minutes}m ${secondsRemaining}s`;
      }

      const avgScanTimeSeconds =
        scanTime && scanTime.avgScanTime ? parseFloat(scanTime.avgScanTime) : 0;
      const formattedScanTime = formatTime(avgScanTimeSeconds);

      const avgCompletionTimeSeconds =
        completionTime && completionTime.avgCompletionTime
          ? parseFloat(completionTime.avgCompletionTime)
          : 0;
      const formattedCompletionTime = formatTime(avgCompletionTimeSeconds);

      // TODO: add names of route source and destination

      return {
        routeId,
        qrGenerated,
        qrScanned,
        scanRate,
        avgScanTime: formattedScanTime,
        avgCompletionTime: formattedCompletionTime,
      };
    });
  },

  getQrCodesPrintedCount: async () => {
    const result = await db
      .select({ count: count() })
      .from(journeys)
      .where(isNotNull(journeys.qrGeneratedAt));

    return result[0].count;
  },

  getQrCodesScannedCount: async () => {
    const result = await db
      .select({ count: count() })
      .from(journeys)
      .where(isNotNull(journeys.qrScannedAt));

    return result[0].count;
  },

  getBananasReturnedCount: async () => {
    const result = await db
      .select({ count: count() })
      .from(events)
      .where(eq(events.eventType, 'banana_return'));

    return result[0].count;
  },

  getMonkeyInteractionsCount: async () => {
    const result = await db.select({ count: count() }).from(journeys);

    return result[0].count;
  },

  getAbandonedInteractionsStats: async () => {
    const buttonPressesCount = await statsService.getMonkeyInteractionsCount();
    const printed = await statsService.getQrCodesPrintedCount();
    const scanned = await statsService.getQrCodesScannedCount();
    const completedJourneys = await db
      .select({ count: count() })
      .from(journeys)
      .where(eq(journeys.status, 'completed'));

    const completedJourneysCount = completedJourneys[0].count;

    const totalJourneys = await db.select({ count: count() }).from(journeys);

    const totalJourneysCount = totalJourneys[0].count;

    const qrPrintedPercentage =
      totalJourneysCount > 0
        ? Number(((printed / totalJourneysCount) * 100).toFixed(2))
        : 0;

    const scannedRate =
      printed > 0 ? Number(((scanned / printed) * 100).toFixed(2)) : 0;

    const abandonedBeforeScan = printed - scanned;
    const abandonmentRateBeforeScan =
      printed > 0
        ? Number(((abandonedBeforeScan / printed) * 100).toFixed(2))
        : 0;

    const abandonedBeforeQR = buttonPressesCount - printed;
    const abandonmentRateBeforeQR =
      buttonPressesCount > 0
        ? Number(((abandonedBeforeQR / buttonPressesCount) * 100).toFixed(2))
        : 0;

    const completionRate =
      totalJourneysCount > 0
        ? Number(
            ((completedJourneysCount / totalJourneysCount) * 100).toFixed(2)
          )
        : 0;

    return {
      total: totalJourneysCount,
      abandonedBeforeQR,
      abandonmentRateBeforeQR,
      abandonedBeforeScan,
      abandonmentRateBeforeScan,
      scannedRate,
      qrPrintedPercentage,
      completedJourneys: completedJourneysCount,
      completionRate,
    };
  },

  getMonkeyUsageStats: async () => {
    const result = await db
      .select({
        monkeyName: monkeys.name,
        interactionCount: count(),
        location: locations.name,
      })
      .from(events)
      .innerJoin(monkeys, eq(events.metadata, monkeys.monkeyId.toString()))
      .innerJoin(locations, eq(events.locationId, locations.id))
      .where(eq(events.eventType, 'button_press'))
      .groupBy(monkeys.name, locations.name)
      .orderBy(desc(count()));

    return result;
  },

  getActiveMonkeysStats: async () => {
    const total = await db.select({ count: count() }).from(monkeys);

    const active = await db
      .select({ count: count() })
      .from(monkeys)
      .where(eq(monkeys.isActive, true));

    const percentActive =
      total[0].count > 0
        ? Number(((active[0].count / total[0].count) * 100).toFixed(2))
        : 0;

    return {
      totalMonkeys: total[0].count,
      activeMonkeys: active[0].count,
      percentActive,
    };
  },

  getDailyTrends: async () => {
    try {
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - 30);

      const formattedStartDate = formatDateToUnix(startDate);
      const formattedEndDate = formatDateToUnix(endDate);

      const buttonPressesQuery = db
        .select({
          date: sql`strftime('%Y-%m-%d', ${journeys.startTime}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            gte(journeys.startTime, sql`${formattedStartDate}`),
            lte(journeys.startTime, sql`${formattedEndDate}`)
          )
        )
        .groupBy(sql`strftime('%Y-%m-%d', ${journeys.startTime}, 'unixepoch')`)
        .orderBy(sql`strftime('%Y-%m-%d', ${journeys.startTime}, 'unixepoch')`);

      const qrGeneratedQuery = db
        .select({
          date: sql`strftime('%Y-%m-%d', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            isNotNull(journeys.qrGeneratedAt),
            gte(journeys.qrGeneratedAt, sql`${formattedStartDate}`),
            lte(journeys.qrGeneratedAt, sql`${formattedEndDate}`)
          )
        )
        .groupBy(
          sql`strftime('%Y-%m-%d', ${journeys.qrGeneratedAt}, 'unixepoch')`
        )
        .orderBy(
          sql`strftime('%Y-%m-%d', ${journeys.qrGeneratedAt}, 'unixepoch')`
        );

      const completedJourneysQuery = db
        .select({
          date: sql`strftime('%Y-%m-%d', ${journeys.endTime}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            eq(journeys.status, 'completed'),
            isNotNull(journeys.endTime),
            gte(journeys.endTime, sql`${formattedStartDate}`),
            lte(journeys.endTime, sql`${formattedEndDate}`)
          )
        )
        .groupBy(sql`strftime('%Y-%m-%d', ${journeys.endTime}, 'unixepoch')`)
        .orderBy(sql`strftime('%Y-%m-%d', ${journeys.endTime}, 'unixepoch')`);

      const [buttonPressesResult, qrGeneratedResult, completedJourneysResult] =
        await Promise.all([
          buttonPressesQuery.execute(),
          qrGeneratedQuery.execute(),
          completedJourneysQuery.execute(),
        ]);

      console.log('Daily trends - button presses', buttonPressesResult);
      console.log('Daily trends - QR generated', qrGeneratedResult);
      console.log('Daily trends - completed journeys', completedJourneysResult);

      const dateRange = generateDateRange(startDate, endDate);

      return dateRange.map((date) => {
        const formattedDate = formatDate(date);

        const buttonPresses =
          buttonPressesResult.find((item) => item.date === formattedDate)
            ?.count || 0;

        const qrCodesGenerated =
          qrGeneratedResult.find((item) => item.date === formattedDate)
            ?.count || 0;

        const journeysCompleted =
          completedJourneysResult.find((item) => item.date === formattedDate)
            ?.count || 0;

        return {
          date: formattedDate,
          buttonPresses,
          qrCodesGenerated,
          journeysCompleted,
        };
      });
    } catch (error) {
      console.error('Error getting daily trends', error);
      throw new Error('Failed to retrieve daily trends data');
    }
  },

  getWeeklyTrends: async () => {
    try {
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - 4 * 7);

      const formattedStartDate = formatDateToUnix(startDate);
      const formattedEndDate = formatDateToUnix(endDate);

      const buttonPressesQuery = db
        .select({
          week: sql`strftime('%Y-%W', ${journeys.startTime}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            gte(journeys.startTime, sql`${formattedStartDate}`),
            lte(journeys.startTime, sql`${formattedEndDate}`)
          )
        )
        .groupBy(sql`strftime('%Y-%W', ${journeys.startTime}, 'unixepoch')`)
        .orderBy(sql`strftime('%Y-%W', ${journeys.startTime}, 'unixepoch')`);

      const qrGeneratedQuery = db
        .select({
          week: sql`strftime('%Y-%W', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            isNotNull(journeys.qrGeneratedAt),
            gte(journeys.qrGeneratedAt, sql`${formattedStartDate}`),
            lte(journeys.qrGeneratedAt, sql`${formattedEndDate}`)
          )
        )
        .groupBy(sql`strftime('%Y-%W', ${journeys.qrGeneratedAt}, 'unixepoch')`)
        .orderBy(
          sql`strftime('%Y-%W', ${journeys.qrGeneratedAt}, 'unixepoch')`
        );

      const completedJourneysQuery = db
        .select({
          week: sql`strftime('%Y-%W', ${journeys.endTime}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            eq(journeys.status, 'completed'),
            gte(journeys.endTime, sql`${formattedStartDate}`),
            lte(journeys.endTime, sql`${formattedEndDate}`)
          )
        )
        .groupBy(sql`strftime('%Y-%W', ${journeys.endTime}, 'unixepoch')`)
        .orderBy(sql`strftime('%Y-%W', ${journeys.endTime}, 'unixepoch')`);

      const [buttonPressesResult, qrGeneratedResult, completedJourneysResult] =
        await Promise.all([
          buttonPressesQuery.execute(),
          qrGeneratedQuery.execute(),
          completedJourneysQuery.execute(),
        ]);

      console.log('Weekly trends - button presses', buttonPressesResult);
      console.log(
        'Weekly trends - completed journeys',
        completedJourneysResult
      );
      console.log('Weekly trends - QR generated', qrGeneratedResult);

      const weekIntervals = generateWeekIntervals(startDate, endDate);

      return weekIntervals.map((weekInterval) => {
        const { startDate, endDate, yearWeek } = weekInterval;

        const buttonPresses =
          buttonPressesResult.find((item) => item.week === yearWeek)?.count ||
          0;

        const qrCodesGenerated =
          qrGeneratedResult.find((item) => item.week === yearWeek)?.count || 0;

        const journeysCompleted =
          completedJourneysResult.find((item) => item.week === yearWeek)
            ?.count || 0;

        return {
          weekStartDate: formatDate(startDate),
          weekEndDate: formatDate(endDate),
          buttonPresses,
          qrCodesGenerated,
          journeysCompleted,
        };
      });
    } catch (error) {
      console.error('Error getting weekly trends', error);
      throw new Error('Failed to retrieve weekly trends data');
    }
  },

  getPeakHoursAnalysis: async () => {
    try {
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const formattedStartDate = formatDateToUnix(thirtyDaysAgo);

      const totalButtonPressesQuery = db
        .select({
          count: count(),
        })
        .from(journeys)
        .where(gte(journeys.startTime, sql`${formattedStartDate}`));

      const hourlyButtonPressesQuery = db
        .select({
          hour: sql`strftime('%H', ${journeys.startTime}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(gte(journeys.startTime, sql`${formattedStartDate}`))
        .groupBy(sql`strftime('%H', ${journeys.startTime}, 'unixepoch')`)
        .orderBy(desc(count()))
        .limit(5);

      const [totalResult, hourlyResult] = await Promise.all([
        totalButtonPressesQuery.execute(),
        hourlyButtonPressesQuery.execute(),
      ]);

      const totalButtonPresses = totalResult[0].count;

      const peakHours = hourlyResult.map((item) => item.hour);

      const qrGeneratedByHourQuery = db
        .select({
          hour: sql`strftime('%H', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            isNotNull(journeys.qrGeneratedAt),
            gte(journeys.qrGeneratedAt, sql`${formattedStartDate}`),
            inArray(
              sql`strftime('%H', ${journeys.qrGeneratedAt}, 'unixepoch')`,
              peakHours
            )
          )
        )
        .groupBy(sql`strftime('%H', ${journeys.qrGeneratedAt}, 'unixepoch')`)
        .orderBy(desc(count()));

      const qrGeneratedByHourResult = await qrGeneratedByHourQuery.execute();

      console.log('Peak hours analysis - button presses', hourlyResult);
      console.log(
        'Peak hours analysis - QR generated',
        qrGeneratedByHourResult
      );

      return hourlyResult.map((hourData) => {
        const hour = hourData.hour;
        const buttonPresses = hourData.count;

        const qrCodesGenerated =
          qrGeneratedByHourResult.find((item) => item.hour === hour)?.count ||
          0;

        const percentageOfDailyTotal = calculatePercentage(
          buttonPresses,
          totalButtonPresses,
          1
        );

        const hourRange = formatHourRange(hour as string);

        return {
          hourRange,
          buttonPresses,
          qrCodesGenerated,
          percentageOfDailyTotal,
        };
      });
    } catch (error) {
      console.error('Error getting peak hours analysis', error);
      throw new Error('Failed to retrieve peak hours analysis data');
    }
  },

  getWeekdayPeakHours: async () => {
    try {
      const twelveWeeksAgo = new Date();
      twelveWeeksAgo.setDate(twelveWeeksAgo.getDate() - 12 * 7);

      const formattedStartDate = formatDateToUnix(twelveWeeksAgo);

      const weekdayPeakHourQuery = db
        .select({
          weekday: sql`strftime('%w', ${journeys.startTime}, 'unixepoch')`,
          hour: sql`strftime('%H', ${journeys.startTime}, 'unixepoch')`,
          buttonPresses: count(),
        })
        .from(journeys)
        .where(gte(journeys.startTime, sql`${formattedStartDate}`))
        .groupBy(
          sql`strftime('%w', ${journeys.startTime}, 'unixepoch')`,
          sql`strftime('%H', ${journeys.startTime}, 'unixepoch')`
        )
        .orderBy(
          sql`strftime('%w', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          desc(count())
        );

      const weekdayInteractionsCountQuery = db
        .select({
          weekday: sql`strftime('%w', ${journeys.startTime}, 'unixepoch')`,
          buttonPresses: count(),
        })
        .from(journeys)
        .where(gte(journeys.startTime, sql`${formattedStartDate}`))
        .groupBy(sql`strftime('%w', ${journeys.startTime}, 'unixepoch')`)
        .orderBy(
          sql`strftime('%w', ${journeys.startTime}, 'unixepoch')`,
          desc(count())
        );

      const weekdayQrGeneratedCountQuery = db
        .select({
          weekday: sql`strftime('%w', ${journeys.startTime}, 'unixepoch')`,
          qrGenerated: count(),
        })
        .from(journeys)
        .where(gte(journeys.startTime, sql`${formattedStartDate}`))
        .groupBy(sql`strftime('%w', ${journeys.qrGeneratedAt}, 'unixepoch')`)
        .orderBy(
          sql`strftime('%w', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          desc(count())
        );

      const weekdayHourlyData = await weekdayPeakHourQuery.execute();
      const weekdayInteractionsCount =
        await weekdayInteractionsCountQuery.execute();
      const weekdayQrGeneratedCount =
        await weekdayQrGeneratedCountQuery.execute();

      console.log('Weekday hourly data', weekdayHourlyData);

      const qrGeneratedByWeekdayHourQuery = db
        .select({
          weekday: sql`strftime('%w', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          hour: sql`strftime('%H', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          count: count(),
        })
        .from(journeys)
        .where(
          and(
            isNotNull(journeys.qrGeneratedAt),
            gte(journeys.qrGeneratedAt, sql`${formattedStartDate}`)
          )
        )
        .groupBy(
          sql`strftime('%w', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          sql`strftime('%H', ${journeys.qrGeneratedAt}, 'unixepoch')`
        )
        .orderBy(
          sql`strftime('%w', ${journeys.qrGeneratedAt}, 'unixepoch')`,
          desc(count())
        );

      const qrGeneratedByWeekdayHour =
        await qrGeneratedByWeekdayHourQuery.execute();

      const weekdays = [
        ...new Set(weekdayHourlyData.map((item) => item.weekday)),
      ];

      return weekdays.map((weekday) => {
        const weekdayData = weekdayHourlyData.filter(
          (item) => item.weekday === weekday
        );

        console.log('-> weekday data', weekdayData);
        weekdayData.sort((a, b) => b.buttonPresses - a.buttonPresses);

        console.log('-> weekday data sorted', weekdayData);

        const peakHourData = weekdayData[0];

        if (!peakHourData) {
          return {
            weekday,
            peakHourRange: 'No data',
            averageButtonPresses: 0,
            averageQrCodesGenerated: 0,
          };
        }

        const qrGeneratedData = qrGeneratedByWeekdayHour.find(
          (item) => item.weekday === weekday && item.hour === peakHourData.hour
        );

        const peakHourRange = formatHourRange(peakHourData.hour as string);

        const totalInteractionsData = weekdayInteractionsCount.find(
          (weekday) => peakHourData.weekday === weekday
        );
        const totalQrGeneratedData = weekdayQrGeneratedCount.find(
          (weekday) => peakHourData.weekday === weekday
        );
        const percentageOfDailyTotalInteractions = (
          peakHourData.buttonPresses /
          (totalInteractionsData?.buttonPresses || peakHourData.buttonPresses)
        ).toFixed(2);

        const averageQrCodesGenerated = Math.round(
          (qrGeneratedData?.count || 0) / 12
        );

        const percentageOfDailyTotalQrGenerated = (
          (qrGeneratedData?.count || 0) /
          (totalQrGeneratedData?.qrGenerated || peakHourData.buttonPresses)
        ).toFixed(2);

        return {
          weekday,
          peakHourRange,
          percentageOfDailyTotalInteractions,
          percentageOfDailyTotalQrGenerated,
        };
      });
    } catch (error) {
      console.error('Error getting weekday peak hours', error);
      throw new Error('Failed to retrieve weekday peak hours data');
    }
  },
};

function formatDate(date: Date): string {
  return date.toISOString().split('T')[0];
}

function formatDateForDb(date: Date): string {
  return date.toISOString().split('T')[0];
}

function formatHourRange(hourString: string): string {
  const hour = Number(hourString);
  const startHour = hour.toString().padStart(2, '0');
  const nextHour: number = (hour + 1) % 24;
  const endHour = nextHour.toString().padStart(2, '0');
  return `${startHour}:00-${endHour}:00`;
}

function formatDateToUnix(jsDate: Date): number {
  return Math.floor(jsDate.getTime() / 1000);
}

function generateDateRange(startDate: Date, endDate: Date): Date[] {
  const dateArray: Date[] = [];
  let currentDate = new Date(startDate);

  while (currentDate <= endDate) {
    dateArray.push(new Date(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }

  return dateArray;
}

function generateWeekIntervals(
  startDate: Date,
  endDate: Date
): { startDate: Date; endDate: Date; yearWeek: string }[] {
  const weekIntervals: { startDate: Date; endDate: Date; yearWeek: string }[] =
    [];
  let currentStartDate = new Date(startDate);

  const dayOfWeek = currentStartDate.getDay();
  const diff = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  currentStartDate.setDate(currentStartDate.getDate() - diff);

  while (currentStartDate < endDate) {
    const weekEndDate = new Date(currentStartDate);
    weekEndDate.setDate(currentStartDate.getDate() + 6);

    const year = currentStartDate.getFullYear();
    const weekNum = getISOWeek(currentStartDate);
    const yearWeek = `${year}${weekNum.toString().padStart(2, '0')}`;

    weekIntervals.push({
      startDate: new Date(currentStartDate),
      endDate: new Date(weekEndDate),
      yearWeek,
    });

    currentStartDate.setDate(currentStartDate.getDate() + 7);
  }

  return weekIntervals;
}

function getISOWeek(date: Date): number {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);
}

function calculatePercentage(
  numerator: number,
  denominator: number,
  decimalPlaces: number = 1
): number {
  if (denominator <= 0) return 0;
  return Number(((numerator / denominator) * 100).toFixed(decimalPlaces));
}
